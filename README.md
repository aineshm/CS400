# DSA Projects Repository

## Data Structures

This repository records my journey through my Data Structures III class, which included learning and implementing Hashtables, RedBlackTrees, Graphs and Dijkstra's Algorithm, as well as using Vim, Git, Bash, and Makefile. It also involved learning about several other DSA concepts such as Minimum Spanning Trees, Tries, Version Control (Git), Bash, and more. This class involved a great deal of group work and communication, and allowed me to learn about how full-stack development works, with groups of 4 being divided into 4 roles - Data Wrangler, Algorithm Engineer, Backend Developer, and Frontend Developer.

P0 - Implementing rotation on a BST, allowing me to build a solid foundation for the RBT project in P2

P1 - Implementation of a Hashtable Map, and also implementing a text based frontend UI

P2 - Implementation of an RBT, and doing so with a Netflix Dataset (from Kaggle). As the Algorithm Engineer, I developed a filtering method in addition to the simple search algorithm, which allowed a user to choose a filtration parameter, and search the entire RBT based on the parameter they wanted. For instance, a user could choose to search by the year of release and choose the year 1999 - resulting in a filtered search of content on Netflix with the release year as 1999.

P3 - Implementation of a Graph and Dijkstra's Algorithm and building on that project by creating a Flight System. As the Backend Developer here, I was able to understand the value of communication in a team, and was able to connect the work of the Data Wrangler and the Algorithm Engineer, along with fixing several bugs I found in the code from all roles. 

## Algorithms

This repository also contains my coursework from my Algorithms class, which taught me both the mathematical logic and the programming skills required to learn algorithms. We covered greedy, divide and conquer, 1D and 2D dynamic programming, network flow problems and intractability. We learnt how to come up with algorithms for problems, as well as prove that they are optimal for our use case.
